<!doctype html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
html {
  font-family: ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji',
    'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
.markmap-dark {
  background: #27272a;
  color: white;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.12/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/index.js"></script><script>(()=>{setTimeout(()=>{const{markmap:S,mm:Q}=window,$=new S.Toolbar;$.attach(Q);const I=$.render();I.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(I)})})()</script><script>((l,U,M,R)=>{const N=l();window.mm=N.Markmap.create("svg#mindmap",(U||N.deriveOptions)(R),M),window.matchMedia("(prefers-color-scheme: dark)").matches&&document.documentElement.classList.add("markmap-dark")})(()=>window.markmap,null,{"content":"Mind Map: Designing Data-Intensive Applications","children":[{"content":"\n<p data-lines=\"2,3\"><strong>Foundations</strong></p>","children":[{"content":"<strong>Reliability</strong>","children":[{"content":"Fault tolerance: System&#x2019;s ability to handle hardware or software failures gracefully.","children":[],"payload":{"tag":"li","lines":"4,5"}},{"content":"Data integrity: Guaranteeing correctness and consistency of stored data.","children":[],"payload":{"tag":"li","lines":"5,6"}},{"content":"Backups and recovery: Mechanisms for restoring data after loss or corruption.","children":[],"payload":{"tag":"li","lines":"6,7"}}],"payload":{"tag":"li","lines":"3,7"}},{"content":"<strong>Scalability</strong>","children":[{"content":"Latency vs. throughput: Balancing response time with the volume of processed requests.","children":[],"payload":{"tag":"li","lines":"8,9"}},{"content":"Scaling up vs. scaling out: Adding more powerful machines versus adding more machines.","children":[],"payload":{"tag":"li","lines":"9,10"}},{"content":"Load balancing: Distributing work evenly across resources.","children":[],"payload":{"tag":"li","lines":"10,11"}}],"payload":{"tag":"li","lines":"7,11"}},{"content":"<strong>Maintainability</strong>","children":[{"content":"Operability: Ease of running and monitoring the system.","children":[],"payload":{"tag":"li","lines":"12,13"}},{"content":"Simplicity: Reducing complexity for easier troubleshooting and changes.","children":[],"payload":{"tag":"li","lines":"13,14"}},{"content":"Evolvability: Facilitating future modifications and scaling.","children":[],"payload":{"tag":"li","lines":"14,16"}}],"payload":{"tag":"li","lines":"11,16"}}],"payload":{"tag":"li","lines":"2,16"}},{"content":"\n<p data-lines=\"16,17\"><strong>Data Models and Storage</strong></p>","children":[{"content":"<strong>Data Models</strong>","children":[{"content":"Relational: Tables with rows and columns, using SQL.","children":[],"payload":{"tag":"li","lines":"18,19"}},{"content":"Document: Storing data as flexible, nested documents (e.g., JSON).","children":[],"payload":{"tag":"li","lines":"19,20"}},{"content":"Graph: Representing entities and relationships as nodes and edges.","children":[],"payload":{"tag":"li","lines":"20,21"}},{"content":"Key-Value: Simple storage of values accessed by unique keys.","children":[],"payload":{"tag":"li","lines":"21,22"}}],"payload":{"tag":"li","lines":"17,22"}},{"content":"<strong>Storage Engines</strong>","children":[{"content":"Log-structured storage: Appends changes to a log for fast writes.","children":[],"payload":{"tag":"li","lines":"23,24"}},{"content":"B-trees: Tree structure optimized for range queries and updates.","children":[],"payload":{"tag":"li","lines":"24,25"}},{"content":"SSTables &amp; LSM-trees: Write-optimized structures for high-throughput workloads.","children":[],"payload":{"tag":"li","lines":"25,26"}}],"payload":{"tag":"li","lines":"22,26"}},{"content":"<strong>Encoding and Evolution</strong>","children":[{"content":"Serialization formats: Methods for encoding data (e.g., JSON, Avro, Protocol Buffers).","children":[],"payload":{"tag":"li","lines":"27,28"}},{"content":"Schema evolution: Managing changes to data formats over time.","children":[],"payload":{"tag":"li","lines":"28,30"}}],"payload":{"tag":"li","lines":"26,30"}}],"payload":{"tag":"li","lines":"16,30"}},{"content":"\n<p data-lines=\"30,31\"><strong>Distributed Data</strong></p>","children":[{"content":"<strong>Replication</strong>","children":[{"content":"Leader-based replication: One node accepts writes, others replicate.","children":[],"payload":{"tag":"li","lines":"32,33"}},{"content":"Leaderless replication: All nodes can accept writes; coordination is needed.","children":[],"payload":{"tag":"li","lines":"33,34"}},{"content":"Quorum: Ensuring a majority of nodes agree on data changes.","children":[],"payload":{"tag":"li","lines":"34,35"}}],"payload":{"tag":"li","lines":"31,35"}},{"content":"<strong>Partitioning (Sharding)</strong>","children":[{"content":"Partitioning strategies: Methods for dividing data (e.g., by key range, hash).","children":[],"payload":{"tag":"li","lines":"36,37"}},{"content":"Rebalancing: Moving data between nodes to maintain even distribution.","children":[],"payload":{"tag":"li","lines":"37,38"}},{"content":"Secondary indexes: Supporting efficient queries on non-primary keys.","children":[],"payload":{"tag":"li","lines":"38,39"}}],"payload":{"tag":"li","lines":"35,39"}},{"content":"<strong>Consistency and Consensus</strong>","children":[{"content":"Consistency models: Trade-offs between immediate and eventual consistency.","children":[],"payload":{"tag":"li","lines":"40,41"}},{"content":"CAP theorem: Principle stating only two of Consistency, Availability, and Partition tolerance can be fully achieved.","children":[],"payload":{"tag":"li","lines":"41,42"}},{"content":"Distributed transactions: Coordinating changes across multiple nodes.","children":[],"payload":{"tag":"li","lines":"42,43"}},{"content":"Consensus algorithms: Protocols like Paxos and Raft for agreeing on state.","children":[],"payload":{"tag":"li","lines":"43,45"}}],"payload":{"tag":"li","lines":"39,45"}}],"payload":{"tag":"li","lines":"30,45"}},{"content":"\n<p data-lines=\"45,46\"><strong>Data Processing</strong></p>","children":[{"content":"<strong>Batch Processing</strong>","children":[{"content":"MapReduce: Programming model for distributed batch jobs.","children":[],"payload":{"tag":"li","lines":"47,48"}},{"content":"Dataflow graphs: Representing computation as a graph of operations.","children":[],"payload":{"tag":"li","lines":"48,49"}},{"content":"Fault tolerance in batch jobs: Recovering from failures during processing.","children":[],"payload":{"tag":"li","lines":"49,50"}}],"payload":{"tag":"li","lines":"46,50"}},{"content":"<strong>Stream Processing</strong>","children":[{"content":"Event time vs. processing time: Handling time semantics in streams.","children":[],"payload":{"tag":"li","lines":"51,52"}},{"content":"Windows and joins: Grouping and combining streaming data.","children":[],"payload":{"tag":"li","lines":"52,53"}},{"content":"Fault tolerance in streams: Ensuring correctness despite failures.","children":[],"payload":{"tag":"li","lines":"53,55"}}],"payload":{"tag":"li","lines":"50,55"}}],"payload":{"tag":"li","lines":"45,55"}},{"content":"\n<p data-lines=\"55,56\"><strong>Derived Data</strong></p>","children":[{"content":"Indexes: Data structures that speed up query performance.","children":[],"payload":{"tag":"li","lines":"56,57"}},{"content":"Caches: Temporary storage for frequently accessed data to reduce latency.","children":[],"payload":{"tag":"li","lines":"57,58"}},{"content":"Materialized views: Precomputed query results stored for fast access.","children":[],"payload":{"tag":"li","lines":"58,59"}},{"content":"Search systems: Specialized engines for full-text search and ranking.","children":[],"payload":{"tag":"li","lines":"59,60"}},{"content":"Data warehouses: Systems optimized for analytical queries on large datasets.","children":[],"payload":{"tag":"li","lines":"60,62"}}],"payload":{"tag":"li","lines":"55,62"}},{"content":"\n<p data-lines=\"62,63\"><strong>Integration</strong></p>","children":[{"content":"Dataflow between systems: Moving and transforming data across different components.","children":[],"payload":{"tag":"li","lines":"63,64"}},{"content":"Change Data Capture (CDC): Tracking and propagating changes from source systems in real time.","children":[],"payload":{"tag":"li","lines":"64,65"}},{"content":"Event sourcing: Storing changes as a sequence of events for auditability and replay.","children":[],"payload":{"tag":"li","lines":"65,66"}},{"content":"Messaging systems: Infrastructure for decoupling producers and consumers (e.g., Kafka, RabbitMQ).","children":[],"payload":{"tag":"li","lines":"66,68"}}],"payload":{"tag":"li","lines":"62,68"}},{"content":"\n<p data-lines=\"68,69\"><strong>Case Studies &amp; Real-World Examples</strong></p>","children":[{"content":"Lessons from industry systems: Insights from large-scale systems at companies like Twitter, LinkedIn, and Google.","children":[],"payload":{"tag":"li","lines":"69,70"}},{"content":"Trade-offs in system design: Real-world examples of balancing reliability, scalability, and maintainability.","children":[],"payload":{"tag":"li","lines":"70,71"}},{"content":"Evolving architectures: How systems adapt to changing requirements and scale over time.","children":[],"payload":{"tag":"li","lines":"71,72"}}],"payload":{"tag":"li","lines":"68,72"}}],"payload":{"tag":"h1","lines":"0,1"}},null)</script>
</body>
</html>
